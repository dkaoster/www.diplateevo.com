<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width,initial-scale=1.0'>

    <link rel="preload" as="style" href="/reset.css" />
    <link rel='stylesheet' href='/reset.css' media="print" onload="this.media='all'" />
    <noscript>
      <link rel='stylesheet' href='/reset.css'>
    </noscript>

    <!-- The Fastest Google Fonts https://csswizardry.com/2020/05/the-fastest-google-fonts/ -->
    <!-- [1] -->
    <link rel="preconnect"
          href="https://fonts.gstatic.com"
          crossorigin />

    <!-- [2] -->
    <link rel="preload"
          as="style"
          href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Noto+Sans+TC&display=swap" />

    <!-- [3] -->
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Noto+Sans+TC&display=swap"
          media="print" onload="this.media='all'" />

    <!-- [4] -->
    <noscript>
      <link rel="stylesheet"
            href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Noto+Sans+TC&display=swap" />
    </noscript>

    <!-- This contains the contents of the <svelte:head> component -->
    
		<link href="../_app/immutable/assets/0.golw3C8A.css" rel="stylesheet">
		<link href="../_app/immutable/assets/4.CzgFuw8o.css" rel="stylesheet">
		<link href="../_app/immutable/assets/PortfolioItem.BZTESynL.css" rel="stylesheet">
		<link href="../_app/immutable/assets/ArchieMLMarkdownHTML.Btt4otIb.css" rel="stylesheet">
		<link rel="modulepreload" href="../_app/immutable/entry/start.2ElrFUm5.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/entry.MIxqKvQ6.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/runtime.B-gH6Wzu.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.BMFLs9XC.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/control.CYgJF_JY.js">
		<link rel="modulepreload" href="../_app/immutable/entry/app.AgIlZJDN.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/preload-helper.EkZnYV-1.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/disclose-version.DwU8uWg_.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/if.DyumFZ97.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/this.9FZqE1rN.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/0.Cle9Rvx2.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/legacy.CI9xy2B2.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/attributes.Bo5QeTel.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/class.DNqF6rXn.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/i18n.B5vvHf5h.js">
		<link rel="modulepreload" href="../_app/immutable/nodes/4.rFsgx1N3.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/4.6yuFoi6w.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/index.g5YcAAdQ.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/image.D5wzb525.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/Helmet.Cw0ip_z2.js">
		<link rel="modulepreload" href="../_app/immutable/chunks/key.CKY86jWL.js"><!--[--><link rel="icon" href="/favicon.svg" type="image/svg+xml"> <link rel="icon" href="/favicon.png" type="image/png"> <link rel="icon" href="/favicon.ico" type="image/x-icon"> <meta name="title" content="ScrollyVideo.js"> <!--[!--><!--]--> <!--[--><meta name="description" content="You’ve probably seen it in a fancy visual journalism piece from a well-known media organization: the scrolling video."><!--]--> <meta property="og:title" content="ScrollyVideo.js"> <meta property="og:type" content="article"> <meta property="og:url" content="https://www.diplateevo.com/scrollyvideo/"> <meta property="og:image" content="https://www.diplateevo.com/images/2023/01/scrollyvideo.jpg"> <meta property="og:site_name" content="Diplateevo"> <meta property="og:locale" content="en_US"> <!--[--><meta property="og:description" content="You’ve probably seen it in a fancy visual journalism piece from a well-known media organization: the scrolling video."><!--]--> <meta name="twitter:image" content="https://www.diplateevo.com/images/2023/01/scrollyvideo.jpg"> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:title" content="ScrollyVideo.js"> <meta name="twitter:description" content="You’ve probably seen it in a fancy visual journalism piece from a well-known media organization: the scrolling video."> <!--[--><script defer="" data-domain="diplateevo.com" src="https://plausible.io/js/plausible.js"></script><!----><!--]--> <!----><!--[!--><!--]--><!----><!--]--><title>ScrollyVideo.js - Diplateevo</title>

  </head>
  <body>
    <!-- The application will be rendered inside this element -->
    <!--[--><!--[--><!----><div class="svelte-bmidcl "><nav class="wrapper svelte-8zm883"><div class="fill svelte-8zm883"></div> <div class="header svelte-8zm883"><a class="logo-link svelte-8zm883" href="/" rel="prefetch"><div class="logo svelte-8zm883">高</div></a> <div class="nav svelte-8zm883"><a class="nav-link svelte-8zm883" href="/" rel="prefetch">Home</a> <!--[--><a class="nav-link svelte-8zm883" href="/about" rel="prefetch">about</a><a class="nav-link svelte-8zm883" href="/works" rel="prefetch">works</a><!--]--> <button class="theme-toggle svelte-8zm883"><!--[!--><svg width="24" viewBox="0 0 47.167 47.167" style="enable-background:new 0 0 47.167 47.167; display: block"><path style="fill: var(--color);" d="M46.369,28.793c-11.852,5.935-26.271,1.138-32.206-10.714c-2.748-5.488-3.191-11.524-1.702-17.016
	C1.197,7.236-3.255,21.263,2.544,32.844C8.479,44.696,22.898,49.493,34.75,43.558c6.364-3.187,10.69-8.821,12.417-15.19
	C46.903,28.513,46.64,28.658,46.369,28.793z"></path></svg><!--]--></button></div></div></nav><!----> <!----><!----><!----> <article class="grid-wrap svelte-12738yp " lang="en"><div class="grid svelte-12738yp"><h1 class="title svelte-12738yp ">ScrollyVideo.js</h1> <!--[--><!--[--><p class="summary svelte-12738yp ">You’ve probably seen it in a fancy visual journalism piece from a well-known media organization: the scrolling video.</p><!--]--> <div class="cover-image svelte-12738yp"><div class="image-wrap cover svelte-1p9e9k9"><!--[--><!--[--><picture class="svelte-1p9e9k9"><!--[--><source media="(max-width: 640px)" srcset="/images/2023/01/scrollyvideo@640w.jpg" type="image/jpeg" class="svelte-1p9e9k9"><source media="(max-width: 768px)" srcset="/images/2023/01/scrollyvideo@768w.jpg" type="image/jpeg" class="svelte-1p9e9k9"><!--]--> <img loading="eager" alt="photograph" src="/images/2023/01/scrollyvideo.jpg" width="100%" class="svelte-1p9e9k9"></picture><!--]--><!--]--> <!--[!--><!--]--></div><!----></div><!--]--> <!--[--><div class="meta svelte-12738yp">Jan 2023</div><!--]--> <!--[!--><!--]--> <!----><!--[--><!--[--><!----><p>You’ve probably seen it in a fancy visual journalism piece from a well-known media organization: the scrolling video. On first thought, it seems simple enough: use Javascript to figure out how far down the page the user has scrolled, and programmatically move the playhead of the video to the appropriate point so that the video reacts to the user’s scroll event.</p>
<!----><!--]--><!--[!--><!--[!--><!--[--><div class="video-wrap full svelte-1f7061r"><!--[--><video alt="video" src="/media/2023/01/scrollyvideo-1.mp4" autoplay muted loop playsinline preload="metadata" class="svelte-1f7061r"></video><!--]--> <!--[!--><!--]--></div><!--]--><!--]--><!--]--><!--[--><!----><p>But it’s not that easy (discussed below), and I’m finally <a target="_blank" rel="noopener noreferrer" href="https://scrollyvideo.js.org/">releasing an open source library</a> with components in React, Svelte, Vue, and vanilla javascript to make scrolling video projects easier. Early versions implementations can be seen in <a target="_blank" rel="noopener noreferrer" href="https://web.cw.com.tw/tra-train-crash/">projects I did for Commonwealth Magazine</a>, or even in <a target="_blank" rel="noopener noreferrer" href="https://www.propublica.org/article/bluestone-jim-justice-north-birmingham">this ProPublica report</a>. This was a project sitting under wraps for nearly year, as it got lost under much of my other day-to-day responsibilities. I finally found the time to clean up the documentation, test different frameworks, and get this project out the door.</p>
<!----><!--]--><!--[--><!----><h2 id="currenttime">CurrentTime</h2>
<!----><!--]--><!--[--><!----><p>Unfortunately, video formats were never designed with this use case in mind, and will often take seconds or longer to load the frame under normal circumstances. Used in a scrolling video, this results in a horribly choppy experience. The reason this happens is videos are typically encoded using keyframes set every 30 frames or so. In videos, keyframes are frames that contain the pixel data for the entire frame, whereas frames that are not keyframes only hold the “difference” between this frame and the last frame. Having frames only encode frames that have changed allows the video to be compressed to a smaller size, as most videos are only expected to be played forwards.</p>
<!----><!--]--><!--[!--><!--[--><div class="image-wrap full svelte-1p9e9k9"><!--[--><!--[--><picture class="svelte-1p9e9k9"><!--[--><source media="(max-width: 640px)" srcset="/images/2023/01/keyframes@640w.png" type="image/png" class="svelte-1p9e9k9"><source media="(max-width: 768px)" srcset="/images/2023/01/keyframes@768w.png" type="image/png" class="svelte-1p9e9k9"><source media="(max-width: 1280px)" srcset="/images/2023/01/keyframes@1280w.png" type="image/png" class="svelte-1p9e9k9"><source media="(max-width: 1920px)" srcset="/images/2023/01/keyframes@1920w.png" type="image/png" class="svelte-1p9e9k9"><!--]--> <img loading="lazy" alt="Keyframes allow video frames to only store the difference from frame to frame." src="/images/2023/01/keyframes.png" width="100%" class="svelte-1p9e9k9"></picture><!--]--><!--]--> <!--[--><div class="caption svelte-1p9e9k9"><!---->Visualizing a video frame simply storing the difference between frames.<!----></div><!--]--></div><!--]--><!--]--><!--[--><!----><p>Therefore, when it comes to exporting video for a “scrolly” use case, the recommendation is to export it with the setting keyframes=1, which tells the encoder that every single frame is a keyframe. While this solves our problem of allowing the video to dynamically load the right frame of the video much faster, it also causes the size of the video file to increase significantly, all other settings being equal. In my experience, going down this path will result in re-exporting the video multiple times while adjusting the quality setting to find a compromise between file size and video quality, which is not ideal.</p>
<!----><!--]--><!--[--><!----><h2 id="playbackrate">PlaybackRate</h2>
<!----><!--]--><!--[--><!----><p>After experimenting with this method for a while, I found a second approach: simply playing and pausing the video while dynamically adjusting the <a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/playbackRate">playback rate</a>. If you’ve ever played around with video player settings, you’ll know that videos on the web often have the option of changing the playback speed of the video, allowing you to power through a lecture at two or three times speed. In fact, most web browsers support up to eight times speed, a speed that I have no honest idea when one would actually want to use in real life. Using playback rate, I can essentially mimic the effect of a user scrolling fast or slow, while relying on the video player to decode the frames in order, making the forward scrolling experience extremely smooth.</p>
<!----><!--]--><!--[--><!----><p>However, the catch with this method is that playback rate cannot be a negative number, so scrolling backwards must still be done with the first method above. Theoretically you could export an identical video in reverse and have two video elements that show or hide depending on the scroll direction, but scrollyVideo.js currently does not support this option. Additionally, Safari for some reason is less performant using this approach than the one above, so this library detects Safari and forces it to use the first method.</p>
<!----><!--]--><!--[--><!----><h2 id="webcodecs">WebCodecs</h2>
<!----><!--]--><!--[--><!----><p>The final approach I stumbled across was using the <a target="_blank" rel="noopener noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API">WebCodecs API</a> to convert a video into individual frames in the browser. Unfortunately, WebCodecs is <a target="_blank" rel="noopener noreferrer" href="https://caniuse.com/webcodecs">only supported in Chrome</a> at the moment, with no estimated release in any of the other browsers. And while I did <a target="_blank" rel="noopener noreferrer" href="https://github.com/ennuicastr/libavjs-webcodecs-polyfill">find a polyfill for WebCodecs</a>, I was unable to get it working with ScrollyVideo, so this method is limited to Chromium-based browsers only.</p>
<!----><!--]--><!--[--><!----><p>Essentially, by reading all the frames from a video ahead of time, this method is able to have any possible frame immediately ready for painting to a canvas. The downside? It takes a bit of time before the video is fully processed, so any immediate usage of this method will likely fall back to one of the earlier ones. Going this route also requires more memory and processing power, something that lower-end android devices may not handle well.</p>
<!----><!--]--><!--[--><!----><h2 id="additional-use-cases">Additional Use Cases</h2>
<!----><!--]--><!--[--><!----><p>For more creative use cases, scrolling may not be the only way that a project may want to control the playback and position of a video. Perhaps you want to control the position of the video based on mouse movement or something else. By exposing <code>setCurrentTimePercent</code> from the library, you can also directly set the position the video.</p>
<!----><!--]--><!--[!--><!--[!--><!--[--><div class="video-wrap full svelte-1f7061r"><!--[--><video alt="video" src="/media/2023/01/scrollyvideo-2.mp4" autoplay muted loop playsinline preload="metadata" class="svelte-1f7061r"></video><!--]--> <!--[!--><!--]--></div><!--]--><!--]--><!--]--><!--[--><!----><h2 id="frameworks">Frameworks</h2>
<!----><!--]--><!--[--><!----><p>That said, the implementation of this project was built with a vanilla javascript installation in mind, with all the logic living inside <a target="_blank" rel="noopener noreferrer" href="https://github.com/dkaoster/scrolly-video/blob/main/src/ScrollyVideo.js">ScrollyVideo.js</a>. The React, Svelte, and Vue components are simply wrappers around the plain javascript implementation, which turns out to be much easier than trying to create a WebComponent.</p>
<!----><!--]--><!--[--><!----><p>That said, I’m looking forward to seeing this in the wild, and if you have any further questions, find any bugs, or want to contribute, feel free to reach out and I’m happy to talk!</p>
<!----><!--]--><!--]--><!----><!----></div></article><!----><!----> <div class="wrapper svelte-1pxpp7n"><div class="footer svelte-1pxpp7n"><h3 class="svelte-1pxpp7n">Diplateevo</h3> <form action="https://buttondown.com/api/emails/embed-subscribe/diplateevo" method="post" target="popupwindow" class="embeddable-buttondown-form svelte-1pxpp7n"><label for="bd-email" class="svelte-1pxpp7n">Subscribe for Updates</label> <input type="email" name="email" id="bd-email" placeholder="you@email.com" class="svelte-1pxpp7n"> <input type="submit" value="Subscribe" class="svelte-1pxpp7n"></form></div></div><!----></div><!----><!--]--> <!--[!--><!--]--><!--]-->
			<script type="application/json" data-sveltekit-fetched data-url="/content/pages.json">{"status":200,"statusText":"","headers":{},"body":"[{\"slug\":\"about\",\"isPage\":true,\"hideRSS\":false,\"en\":{\"title\":\"Graphics Journalist, Digital Cartographer, Engineer, Noodle Connoisseur\",\"isPage\":\"true\",\"description\":\"I spend my days crunching data and visualizing news stories for the web and mobile devices.\",\"slug\":\"about\",\"locale\":\"en\"},\"zh\":{\"title\":\"資料視覺化前端工程師、數位地理資訊學者、湯麵愛好者\",\"isPage\":\"true\",\"description\":\"我專門發想以及製作新聞和資料視覺化。\",\"slug\":\"about\",\"locale\":\"zh\"}},{\"slug\":\"works\",\"isPage\":true,\"hideRSS\":false,\"en\":{\"title\":\"My Projects\",\"isPage\":\"true\",\"description\":\"A few selected works and write-ups of projects worth sharing.\",\"slug\":\"works\",\"locale\":\"en\"},\"zh\":{\"title\":\"我的作品集\",\"isPage\":\"true\",\"description\":\"A few selected works and write-ups of projects worth sharing.\",\"slug\":\"works\",\"locale\":\"zh\"}}]"}</script>
			<script type="application/json" data-sveltekit-fetched data-url="/content/scrollyvideo.json">{"status":200,"statusText":"","headers":{},"body":"{\"en\":{\"title\":\"ScrollyVideo.js\",\"publishDate\":\"2023/01/16\",\"author\":\"Daniel Kao\",\"description\":\"You’ve probably seen it in a fancy visual journalism piece from a well-known media organization: the scrolling video.\",\"featureImage\":\"/images/2023/01/scrollyvideo.jpg\",\"storyCardThumb\":\"/images/2023/01/scrollyvideo-thumb.jpg\",\"content\":[{\"type\":\"text\",\"value\":\"\u003Cp>You’ve probably seen it in a fancy visual journalism piece from a well-known media organization: the scrolling video. On first thought, it seems simple enough: use Javascript to figure out how far down the page the user has scrolled, and programmatically move the playhead of the video to the appropriate point so that the video reacts to the user’s scroll event.\u003C/p>\\n\"},{\"type\":\"video\",\"value\":{\"src\":\"/media/2023/01/scrollyvideo-1.mp4\",\"className\":\"full\",\"autoplay\":\"true\",\"muted\":\"true\",\"loop\":\"true\",\"playsinline\":\"true\",\"preload\":\"metadata\"}},{\"type\":\"text\",\"value\":\"\u003Cp>But it’s not that easy (discussed below), and I’m finally \u003Ca target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\" href=\\\"https://scrollyvideo.js.org/\\\">releasing an open source library\u003C/a> with components in React, Svelte, Vue, and vanilla javascript to make scrolling video projects easier. Early versions implementations can be seen in \u003Ca target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\" href=\\\"https://web.cw.com.tw/tra-train-crash/\\\">projects I did for Commonwealth Magazine\u003C/a>, or even in \u003Ca target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\" href=\\\"https://www.propublica.org/article/bluestone-jim-justice-north-birmingham\\\">this ProPublica report\u003C/a>. This was a project sitting under wraps for nearly year, as it got lost under much of my other day-to-day responsibilities. I finally found the time to clean up the documentation, test different frameworks, and get this project out the door.\u003C/p>\\n\"},{\"type\":\"text\",\"value\":\"\u003Ch2 id=\\\"currenttime\\\">CurrentTime\u003C/h2>\\n\"},{\"type\":\"text\",\"value\":\"\u003Cp>Unfortunately, video formats were never designed with this use case in mind, and will often take seconds or longer to load the frame under normal circumstances. Used in a scrolling video, this results in a horribly choppy experience. The reason this happens is videos are typically encoded using keyframes set every 30 frames or so. In videos, keyframes are frames that contain the pixel data for the entire frame, whereas frames that are not keyframes only hold the “difference” between this frame and the last frame. Having frames only encode frames that have changed allows the video to be compressed to a smaller size, as most videos are only expected to be played forwards.\u003C/p>\\n\"},{\"type\":\"image\",\"value\":{\"src\":\"/images/2023/01/keyframes.png\",\"alt\":\"Keyframes allow video frames to only store the difference from frame to frame.\",\"className\":\"full\",\"caption\":\"Visualizing a video frame simply storing the difference between frames.\",\"crops\":[{\"image\":\"/images/2023/01/keyframes.png\",\"width\":1920,\"format\":\"png\"},{\"image\":\"/images/2023/01/keyframes.png\",\"width\":1280,\"format\":\"png\"},{\"image\":\"/images/2023/01/keyframes.png\",\"width\":768,\"format\":\"png\"},{\"image\":\"/images/2023/01/keyframes.png\",\"width\":640,\"format\":\"png\"}]}},{\"type\":\"text\",\"value\":\"\u003Cp>Therefore, when it comes to exporting video for a “scrolly” use case, the recommendation is to export it with the setting keyframes=1, which tells the encoder that every single frame is a keyframe. While this solves our problem of allowing the video to dynamically load the right frame of the video much faster, it also causes the size of the video file to increase significantly, all other settings being equal. In my experience, going down this path will result in re-exporting the video multiple times while adjusting the quality setting to find a compromise between file size and video quality, which is not ideal.\u003C/p>\\n\"},{\"type\":\"text\",\"value\":\"\u003Ch2 id=\\\"playbackrate\\\">PlaybackRate\u003C/h2>\\n\"},{\"type\":\"text\",\"value\":\"\u003Cp>After experimenting with this method for a while, I found a second approach: simply playing and pausing the video while dynamically adjusting the \u003Ca target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\" href=\\\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/playbackRate\\\">playback rate\u003C/a>. If you’ve ever played around with video player settings, you’ll know that videos on the web often have the option of changing the playback speed of the video, allowing you to power through a lecture at two or three times speed. In fact, most web browsers support up to eight times speed, a speed that I have no honest idea when one would actually want to use in real life. Using playback rate, I can essentially mimic the effect of a user scrolling fast or slow, while relying on the video player to decode the frames in order, making the forward scrolling experience extremely smooth.\u003C/p>\\n\"},{\"type\":\"text\",\"value\":\"\u003Cp>However, the catch with this method is that playback rate cannot be a negative number, so scrolling backwards must still be done with the first method above. Theoretically you could export an identical video in reverse and have two video elements that show or hide depending on the scroll direction, but scrollyVideo.js currently does not support this option. Additionally, Safari for some reason is less performant using this approach than the one above, so this library detects Safari and forces it to use the first method.\u003C/p>\\n\"},{\"type\":\"text\",\"value\":\"\u003Ch2 id=\\\"webcodecs\\\">WebCodecs\u003C/h2>\\n\"},{\"type\":\"text\",\"value\":\"\u003Cp>The final approach I stumbled across was using the \u003Ca target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\" href=\\\"https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API\\\">WebCodecs API\u003C/a> to convert a video into individual frames in the browser. Unfortunately, WebCodecs is \u003Ca target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\" href=\\\"https://caniuse.com/webcodecs\\\">only supported in Chrome\u003C/a> at the moment, with no estimated release in any of the other browsers. And while I did \u003Ca target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\" href=\\\"https://github.com/ennuicastr/libavjs-webcodecs-polyfill\\\">find a polyfill for WebCodecs\u003C/a>, I was unable to get it working with ScrollyVideo, so this method is limited to Chromium-based browsers only.\u003C/p>\\n\"},{\"type\":\"text\",\"value\":\"\u003Cp>Essentially, by reading all the frames from a video ahead of time, this method is able to have any possible frame immediately ready for painting to a canvas. The downside? It takes a bit of time before the video is fully processed, so any immediate usage of this method will likely fall back to one of the earlier ones. Going this route also requires more memory and processing power, something that lower-end android devices may not handle well.\u003C/p>\\n\"},{\"type\":\"text\",\"value\":\"\u003Ch2 id=\\\"additional-use-cases\\\">Additional Use Cases\u003C/h2>\\n\"},{\"type\":\"text\",\"value\":\"\u003Cp>For more creative use cases, scrolling may not be the only way that a project may want to control the playback and position of a video. Perhaps you want to control the position of the video based on mouse movement or something else. By exposing \u003Ccode>setCurrentTimePercent\u003C/code> from the library, you can also directly set the position the video.\u003C/p>\\n\"},{\"type\":\"video\",\"value\":{\"src\":\"/media/2023/01/scrollyvideo-2.mp4\",\"className\":\"full\",\"autoplay\":\"true\",\"muted\":\"true\",\"loop\":\"true\",\"playsinline\":\"true\",\"preload\":\"metadata\"}},{\"type\":\"text\",\"value\":\"\u003Ch2 id=\\\"frameworks\\\">Frameworks\u003C/h2>\\n\"},{\"type\":\"text\",\"value\":\"\u003Cp>That said, the implementation of this project was built with a vanilla javascript installation in mind, with all the logic living inside \u003Ca target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\" href=\\\"https://github.com/dkaoster/scrolly-video/blob/main/src/ScrollyVideo.js\\\">ScrollyVideo.js\u003C/a>. The React, Svelte, and Vue components are simply wrappers around the plain javascript implementation, which turns out to be much easier than trying to create a WebComponent.\u003C/p>\\n\"},{\"type\":\"text\",\"value\":\"\u003Cp>That said, I’m looking forward to seeing this in the wild, and if you have any further questions, find any bugs, or want to contribute, feel free to reach out and I’m happy to talk!\u003C/p>\\n\"}],\"featureImageCrops\":[{\"image\":\"/images/2023/01/scrollyvideo.jpg\",\"width\":768,\"format\":\"jpg\"},{\"image\":\"/images/2023/01/scrollyvideo.jpg\",\"width\":640,\"format\":\"jpg\"}],\"storyCardThumbCrops\":[],\"slug\":\"scrollyvideo\",\"locale\":\"en\"}}"}</script>
			<script>
				{
					__sveltekit_6eftkp = {
						base: new URL("..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					const data = [null,null];

					Promise.all([
						import("../_app/immutable/entry/start.2ElrFUm5.js"),
						import("../_app/immutable/entry/app.AgIlZJDN.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 4],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		
  </body>
</html>
